#!/bin/bash
#
# setup-db
#
# A script for setting up a DB with MonetDB containing the SSB (Star-
# Schema Benchmark) schema, and generated its data set. It must be run
# after MonetDB itself has been properly installed as is available on
# the executable path.
# 
#################################################################################
# By Eyal Rozenberg <E.Rozenberg@cwi.nl>
##################################################################################
#
#

#------------------------------
# Helper functions

function usage {
	AUTHOR="Eyal Rozenberg"
	CONTACT_EMAIL="E.Rozenberg@cwi.nl"
	echo "Usage: $0 [OPTIONS...]"
	echo "Downloads, build and installs MonetDB and the dbgen utlilities; generates SSB"
	echo "data, creates a DB farm, creates a DB and loads the data there."
	echo 
	echo "Options:"
	echo "  -r, --recreate              If the SSB database exists, recreate it, dropping"
	echo "                              all existing data. (If this option is unset, the "
	echo "                              database must not already exist)"
	echo "  -s, --scale-factor FACTOR   The amount of test data to generate, in GB"
	echo "  -G, --use-generated         Use previously-generated table load files (in the"
	echo "                              data generation directory instead of re-generating"
	echo "                              them using the dbgen utility."
	echo "  -g, --dbgen-dir             Look for the SSB data generation utility in the"
	echo "                              specified directory."
	echo "  -l, --log-file FILENAME     Name of the file to log output into"
	echo "  -d, --db-name NAME          Name of the database holding SSB test data"
	echo "                              within the DB farm" 
	echo "  -f, --db-farm PATH          Filesystem path for the root directory of the DB farm"
	echo "                              with the generated DB"
	echo "  -p, --port NUMBER           Network port on the local host, which the server"
	echo "                              will related to the DB farm"
	echo "  -D, --data-gen-dir PATH     directory in which to generate the SSB table data"
	echo "  -k, --keep-raw-tables       Keep the raw data generated by the tool outside of"
	echo "                              the DBMS"
	echo 
	echo "For questions and details, contact $AUTHOR <$CONTACT_EMAIL> (or just read the source)."
}


function die {
	echo -e "$1" >&2   # error message to stderr 
	exit ${2:-1}  # default exit code is -1 but you can specify something else
}

function gb_available_space_for_dir {
	# Note this returns the number of 2^30 bytes, not 10^9
	 df --block-size=G --output=avail $1 | tail -1 | grep -o "[0-9]*"
}

function is_positive_int {
	[[ $1 =~ ^[0-9]+$ ]] && [[ ! $1 =~ ^0+$ ]]
}

# (monetdb's command-line utilities are not so great
# at reporting the status of things in machine-readable format)

function db_farm_exists {
    [[ $(monetdbd get all $1 2>/dev/null | wc -l)  -ne 0 ]]
}

function property_of_dbfarm {
    local property_name="$1"
    local db_farm="$2"
    monetdbd get $property_name $db_farm | tail -1 | sed "s/$property_name *//;"
}

function db_farm_is_up {
    db_farm="$1"
    # When a DB farm is up, the status is "monetdbd[process num here] version here (release name here) is serving this dbfarm";
    # when it's down, the status is "no monetdbd is serving this dbfarm"
    [[ $(property_of_dbfarm status $1) =~ "monetdbd[" ]]
}

function db_is_up {
    # This assumes the DB exists
    local db_name=$1
    [[ "$be_verbose" ]] && echo monetdb -p $port status $db_name 2>/dev/null
    status=$(monetdb -p $port status $db_name 2>/dev/null | tail -1 | sed -r 's/^'$db_name'\s*([^ ]*).*$/\1/;')
    [[ "$be_verbose" ]] && echo "Database $db_name is" $(echo $status | sed 's/R/running/; s/S/not running/; s/^$/not running/')
    [[ -n "$status" && $status == "R" ]] && return 0 || return 1
}

function db_exists {
    local db_name=$1
    local port=$2
    [[ $(monetdb -p $port status $db_name 2>/dev/null | wc -l) > 0 ]]
}

function run_mclient {
    local language="sql"
    local queries="$1"
    local format="${2:-csv}"
    [[ $be_verbose ]] && echo "mclient -lsql -f $format -d $db_name -p $port -s \"\$queries\""
    mclient -lsql -f $format -d $db_name -p $port -s "$queries" 
}

function dbgen_is_valid {
	[[ -n $($dbgen_binary -h 2>&1 | head -1 | egrep "SSBM? \\(Star Schema Benchmark\\) Population Generator") ]]
}


#------------------------------

TODAY=$(date +%Y-%m-%d)

# Default parameter values here...

schema_creation_query_file="other_queries/create_schema_with_constraints.sql"
scale_factor=1
dbgen_dir="$(pwd)/dbgen"
data_generation_base_dir="$(pwd)"
data_generation_dir="${data_generation_base_dir}/dbgen-${TODAY}"
log_file="${0}.log"
keep_raw_tables=
port=50000

#------------------------------
# Parse command line here
#
while [[ $# > 0 ]]; do
	option_key="$1"
	
	case $option_key in
	-v|--verbose)
	    be_verbose=1
	    ;;
	-r|--recreate)
	    recreate_db=1
	    ;;
	-s|--scale-factor|--sf)
		scale_factor="$2"
		is_positive_int $scale_factor || die "Invalid scale factor $scale_factor"
		shift # past argument
		;;
	-g|--dbgen-dir)
		raw_db_dir="$2"
		dbgen_dir=${raw_db_dir%%+(/)}
		dbgen_binary=$dbgen_dir/dbgen
		dbgen_dists_file=$dbgen_dir/dists.dss
		shift # past argument
		;;
	-G|--data-already-generated|--already-generated|--have-generated-data|--have-generated)
		already_generated=1
		;;
	-d|--dbname|--db-name|--database-name)
		db_name="$2"
		shift # past argument
		;;
	-l|--log-file)
		log_file="$2"
		shift # past argument
		;;
	-f|--farm|--db-farm|--dbfarm|--database-farm)
		db_farm="$2"
		shift # past argument
		;;
	-p|--port|--dbfarm-port)
		port="$2"
		shift # past argument
		is_positive_int $port || die "Invalid DB farm port $port"
		;;
	-D|--data-gen-dir|--data-generation-directory|--data-generation-dir|--gen-dir|--data-gen-directory)
		raw_data_generation_dir="$2"
		data_generation_dir=${raw_data_generation_dir%%/}
		shift # past argument
		;;
	-k|--keep-raw-tables|--keep-raw)
		keep_raw_tables=1
		;;
	*) # unknown option
		echo "Unknown command line option $option_key" 1>&2
		break
#		usage
#		exit -1
		;;
	esac
	shift # past argument or value
done
if [[ $# > 0 ]]; then
	usage
	exit -1
fi

if [[ -z "$keep_raw_tables" ]] && [[ -n "already_generated" ]]; then
	keep_raw_table=1	
fi

[[ -n "$db_name" ]] || db_name="ssb-sf-$scale_factor"

[[ -n "$db_farm" ]] || db_farm="$DB_FARM"
[[ -n "$db_farm" ]] || db_farm="$HOME/db_farms/monetdb"

#
#------------------------------

# This makes sure both the console and the log file get both stderr and stdout
exec >& >(tee $log_file)

# Derived non-user-controlled parameters

if [[ -z "$already_generated" ]]; then
	if [[ -z $dbgen_binary ]] || [[ -z $dbgen_dists_file ]] ; then
		if [[ -z $dbgen_dir ]]; then
			echo "Could not locate the SSB dbgen tool directory/binary & dists file" >&2
			echo "(you did not specify their location using -g)"
			exit -1
		fi
	fi
	[[ -n $dbgen_dists_file ]] || dbgen_dists_file=$dbgen_dir/dists.dss
	[[ -n $dbgen_binary ]] || dbgen_binary=$dbgen_dir/dbgen
	if [[ ! -r $dbgen_dists_file ]]; then
		echo "Cannot read dbgen dists file $dbgen_dists_file" >&2
		exit -1
	fi
	if [[ ! -f $dbgen_binary ]]; then
		if [[ ! -f $dbgen_dir/Makefile ]]; then
			[[ -f $dbgen_dir/CMakeLists.txt ]] || die "Missing CMakeLists.txt in the DBGEN directory $dbgen_dir - can't generate Makefile"
			pushd $dbgen_dir
			cmake .
			popd
		fi
		[[ -f $dbgen_dir/Makefile ]] || die "Could not find nor generate a Makefile in $dbgen_dir"
		make -C $dbgen_dir || die "Failed building the dbgen utility."
	fi
			
	if [[ ! -f $dbgen_binary ]]; then
		echo "Cannot find the dbgen data generation binary at $dbgen_binary. (Perhaps something went wrong with the build?)" >&2
		exit -1
	fi 
	if [[ ! -x $dbgen_binary ]]; then
		echo "The dbgen data generation binary at $dbgen_binary is not an executable file." >&2
		exit -1
	fi 
	dbgen_is_valid || die "Invalid SSB data generator binary $dbgen_binary"
fi



# Note: We don't really need that extra space, but... better be on the safe side (especially if the .tbl directory and the DB farm are on the same partition)
necessary_space_in_gb=$(( 2 * $scale_factor ))
read -r -d '' schema_creation_sql << EOF
start TRANSACTION;

CREATE TABLE date_ (
	d_datekey          INT,     -- identifier, unique id -- e.g. 19980327 (what we use)
	d_date             STRING,  -- varchar(18), --fixed text, size 18, longest: december 22, 1998
	d_dayofweek        STRING,  -- varchar(8), --fixed text, size 8, sunday, monday, ..., saturday)
	d_month            STRING,  -- varchar(9), --fixed text, size 9: january, ..., december
	d_year             INT,     -- unique value 1992-1998
	d_yearmonthnum     INT,     -- numeric (yyyymm) -- e.g. 199803
	d_yearmonth        STRING,  -- varchar(7), --fixed text, size 7: mar1998 for example
	d_daynuminweek     INT,     -- numeric 1-7
	d_daynuminmonth    INT,     -- numeric 1-31
	d_daynuminyear     INT,     -- numeric 1-366
	d_monthnuminyear   INT,     -- numeric 1-12
	d_weeknuminyear    INT,     -- numeric 1-53
	d_sellingseason    STRING,  -- varchar(12), --text, size 12 (christmas, summer,...)
	d_lastdayinweekfl  INT,     -- 1 bit
	d_lastdayinmonthfl INT,     -- 1 bit
	d_holidayfl        INT,     -- 1 bit
	d_weekdayfl        INT,     -- 1 bit
	PRIMARY KEY (d_datekey) 
);

CREATE TABLE supplier (
	s_suppkey INT,     -- identifier
	s_name    STRING,  -- varchar(25), --fixed text, size 25: 'supplier'||suppkey
	s_address STRING,  -- varchar(25), --variable text, size 25 (city below)
	s_city    STRING,  -- varchar(10), --fixed text, size 10 (10/nation: nation_prefix||(0-9))
	s_nation  STRING,  -- varchar(15), --fixed text(15) (25 values, longest united kingdom)
	s_region  STRING,  -- varchar(12), --fixed text, size 12 (5 values: longest middle east)
	s_phone   STRING,  -- varchar(15) --fixed text, size 15 (many values, format: 43-617-354-1222)
	PRIMARY KEY (s_suppkey)
);

CREATE TABLE customer (
	c_custkey    INT,--numeric identifier
	c_name       STRING,     -- varchar(25), --variable text, size 25 'customer'||custkey
	c_address    STRING,     -- varchar(25), --variable text, size 25 (city below)
	c_city       STRING,     -- varchar(10), --fixed text, size 10 (10/nation: nation_prefix||(0-9)
	c_nation     STRING,     -- varchar(15), --fixed text(15) (25 values, longest united kingdom)
	c_region     STRING,     -- varchar(12), --fixed text, size 12 (5 values: longest middle east)
	c_phone      STRING,     -- varchar(15), --fixed text, size 15 (many values, format: 43-617-354-1222)
	c_mktsegment STRING,     -- varchar(10) --fixed text, size 10 (longest is automobile)
	PRIMARY KEY (c_custkey)
);

CREATE TABLE part (
	p_partkey   INT,        -- identifier
	p_name      STRING,     -- varchar(22), --variable text, size 22 (not unique per part but never was)
	p_mfgr      STRING,     -- varchar(6), --fixed text, size 6 (mfgr#1-5, card = 5)
	p_category  STRING,     -- varchar(7), --fixed text, size 7 ('mfgr#'||1-5||1-5: card = 25)
	p_brand1    STRING,     -- varchar(9), --fixed text, size 9 (category||1-40: card = 1000)
	p_color     STRING,     -- varchar(11), --variable text, size 11 (card = 94)
	p_type      STRING,     -- varchar(25), --variable text, size 25 (card = 150)
	p_size      INT,        -- numeric 1-50 (card = 50)
	p_container STRING,     -- varchar(15) --fixed text(10) (card = 40)
	PRIMARY KEY (p_partkey)
);

CREATE TABLE lineorder (
	lo_orderkey      INT,     -- numeric (int up to sf 300) first 8 of each 32 keys used
	lo_linenumber    INT,     -- numeric 1-7
	lo_custkey       INT,     -- numeric identifier foreign key reference to c_custkey
	lo_partkey       INT,     -- identifier foreign key reference to p_partkey
	lo_suppkey       INT,     -- numeric identifier foreign key reference to s_suppkey
	lo_orderdate     INT,     -- identifier foreign key reference to d_datekey
	lo_orderpriority STRING,  -- varchar(15), --fixed text, size 15 (5 priorities: 1-urgent, etc.)
	lo_shippriority  STRING,  -- varchar(1), --fixed text, size 1
	lo_quantity      INT,     -- numeric 1-50 (for part)
	lo_extendedprice INT,     -- numeric, max about 55,450 (for part)
	lo_ordtotalprice INT,     -- numeric, max about 388,000 (for order)
	lo_discount      INT,     -- numeric 0-10 (for part) -- (represents percent)
	lo_revenue       INT,     -- numeric (for part: (extendedprice*(100-discount))/100)
	lo_supplycost    INT,     -- numeric (for part, cost from supplier, max = ?)
	lo_tax           INT,     -- numeric 0-8 (for part)
	lo_commitdate    INT,     -- foreign key reference to d_datekey
	lo_shipmode      STRING,  -- varchar(10) --fixed text, size 10 (modes: reg air, air, etc.)
	PRIMARY KEY (lo_orderkey, lo_linenumber), --Compound Primary Key: ORDERKEY, LINENUMBER
	FOREIGN KEY (lo_orderdate)  REFERENCES date_    (d_datekey), --identifier foreign key reference to D_DATEKEY
	FOREIGN KEY (lo_commitdate) REFERENCES date_    (d_datekey), --Foreign Key reference to D_DATEKEY
	FOREIGN KEY (lo_suppkey)    REFERENCES supplier (s_suppkey), --numeric identifier foreign key reference to S_SUPPKEY
	FOREIGN KEY (lo_custkey)    REFERENCES customer (c_custkey)  --numeric identifier foreign key reference 
);

COMMIT; 
EOF
# ... that was the SQL for creating the schema and the key cosntraints


read -r -d '' table_loading_sql_template << EOF
START TRANSACTION;
COPY INTO customer  from 'PWD/customer.tbl'   USING DELIMITERS '|', '|\n';
COPY INTO date_     from 'PWD/date.tbl'       USING DELIMITERS '|', '|\n';
COPY INTO part      from 'PWD/part.tbl'       USING DELIMITERS '|', '|\n';
COPY INTO supplier  from 'PWD/supplier.tbl'   USING DELIMITERS '|', '|\n';
COPY INTO lineorder from 'PWD/lineorder.tbl'  USING DELIMITERS '|', '|\n';
COMMIT;
EOF

for binary in monetdb monetdbd; do
	[[ -n `which $binary` ]] || die "Missing MonetDB binary $binary"
done

[[ -d $db_farm ]] || mkdir -p $db_farm || die "Failed creating a directory for the DB farm at $db_farm"

if [[ -z "$already_generated" ]]; then
	[[ ! -d $data_generation_dir ]] || die "The intended data generation directory $data_generation_dir is already present;\nYou must either remove it, name a subdir, or set -G if it contains the generated data"
	(( $(gb_available_space_for_dir $data_generation_base_dir) > $necessary_space_in_gb )) || 
	die "Not enough disk space at $data_generation_base_dir to generate the SSB data: We need ${NECCESSARY_SPACE_IN_GB} GiB but have $(gb_available_space_for_dir $data_generation_base_dir) GiB."
fi

# Avoid the annoying password prompt if possible...
[[ -r "$HOME/.monetdb" ]] || echo -e "user=monetdb\npassword=monetdb\nlanguage=sql\n" > $HOME/.monetdb

# Ensure we have a DB farm that's up in which to create the SSB DB - or try to create it

if db_farm_exists $db_farm; then
    port=$(property_of_dbfarm "port" $db_farm)
    db_farm_is_up $db_farm || monetdbd start $db_farm || die "Could not start the DB farm at $db_farm"
else
    [[ "$be_verbose" ]] && echo "monetdbd create $db_farm" 
    monetdbd create $db_farm || die "A MonetDB database farm does not exist at ${db_farm}, and cannot be created there."
    [[ "$be_verbose" ]] && echo "monetdbd set port=$port $db_farm"
    monetdbd set port=$port $db_farm || die "Can't set the daemon port for new DB farm ${db_farm} to ${port}."
    [[ "$be_verbose" ]] && echo "monetdbd start $db_farm"
    monetdbd start $db_farm || die
fi

db_farm_is_up $db_farm || die "Could not get DB farm at $db_farm to the started state"

if db_exists "$db_name" "$port"; then
    if db_is_up "$db_name" "$port"; then
        [[ "$be_verbose" ]] &&  echo "monetdb -p $port stop $db_name"
        monetdb -p $port stop $db_name  >/dev/null || die "Can't stop the existing DB named $db_name in DB farm $db_farm."
    fi
    if [[ "$recreate_db" ]]; then
        [[ "$be_verbose" ]] &&  echo "monetdb -p $port destroy -f $db_name" 
        monetdb -p $port destroy -f $db_name >/dev/null || die "Failed destroying the existing DB named $db_name in DB farm $db_farm."
        need_to_create_the_db=1
    else
        die "A database named $db_name already exists in DB farm ${db_farm}, so giving up. Perhaps you wanted to recreate it?"
    fi
else
    need_to_create_the_db=1
fi

(( $(gb_available_space_for_dir $db_farm) > $necessary_space_in_gb )) ||
die "Not enough disk space at $db_farm to generate the SSB data: We need ${necessary_space_in_gb} GiB but have $(gb_available_space_for_dir $db_farm) GiB."

# Create the DB and SQL-create its schema 

if [[ "$need_to_create_the_db" ]]; then
	[[ "$be_verbose" ]] && echo "Creating the empty database $db_name in DB farm $db_farm"
    (
    ( [[ "$be_verbose" ]] && echo "monetdb -p $port create $db_name" ; monetdb -p $port create $db_name > /dev/null ) &&
    ( [[ "$be_verbose" ]] && echo "monetdb -p $port release $db_name" ;  monetdb -p $port release $db_name > /dev/null )
    ) || die "Failed to create (and release) a database named $db_name in DB farm $db_farm"
	[[ "$be_verbose" ]] && echo "Populating the schema of database $db_name"
    run_mclient "$schema_creation_sql"
fi

# Generate the SSB data

if [[ -z "$already_generated" ]] ; then
	[[ ! -d $data_generation_dir ]] || die "The intended data generation directory $data_generation_dir is already present; either remove it or set another directory name - picking up after generation is not supported right now."
	mkdir -p $data_generation_dir || die "Can't create staging directory $data_generation_dir for generating SSB data"
	pushd $data_generation_dir >/dev/null
	escaped_path_of_generation_dir=$(echo "$PWD" | sed 's/\//\\\//g')
	table_loading_sql=$(echo "$table_loading_sql_template" | sed -e "s/PWD/$escaped_path_of_generation_dir/")
	[[ "$be_verbose" ]] && dbgen_verbosity_option="-v"
	[[ "$be_verbose" ]] && echo "$dbgen_binary -v -b $dbgen_dists_file -s $scale_factor "
	# Unfortunately, for now, we need to generate each table separately.
	echo >&2 $dbgen_binary -b $dbgen_dists_file -s $scale_factor
	$dbgen_binary -b $dbgen_dists_file -s $scale_factor $dbgen_verbosity_option || die "Failed generating SSB data using $dbgen_binary with scale factor $scale_factor, at $data_generation_dir"
	popd >&/dev/null
else
	[[ -d $data_generation_dir ]] || die "Pre-generated data directory $data_generation_dir is missing"
fi

# Data generation is complete, time to load it
 
[[ "$be_verbose" ]] && echo "Loading generated data from $data_generation_dir"
echo "$table_loading_sql" | sed -r '/\.tbl/!d'"; s/^.*from '([^']*).*$/\1/;" | while read table_file; do
	[[ -r $table_file ]] || die "Could not find the generated data file ${table_file} - perhaps its generation failed?"
done
run_mclient "$table_loading_sql"

[[ -n "$keep_raw_tables" ]] || rm -r $data_generation_dir
